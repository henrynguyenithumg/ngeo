{"version":3,"sources":["webpack:///./examples/attributes.js","webpack:///./src/format/XSDAttribute.js"],"names":["__webpack_require__","exports","module","angular","_module2","default","name","_attributesComponent2","MainController","$http","$timeout","$scope","_this","this","timeout_","attributes","disabled","feature","_Feature2","kind","get","then","handleXSDAttributeGet_","bind","log","$watch","newValue","oldValue","appendLog","prototype","resp","_XSDAttribute2","read","data","updateName","_this2","set","newMessage","controller","e","Error","code","olBase","_XML2","call","inherits","source","readFromDocument","doc","_asserts2","assert","nodeType","Node","DOCUMENT_NODE","n","firstChild","nextSibling","ELEMENT_NODE","readFromNode","node","localName","elements","getElementsByTagName","length","attribute","i","ii","readFromElementNode_","push","getAttribute","assertString","alias","nillable","required","type","_Attribute2","setGeometryType","setAttributeByXsdType_","enumerations","_AttributeType2","SELECT","choices","restrictions","restrictionNode","maxLengths","maxLength","Number","BOOLEAN","DATE","DATETIME","TIME","NUMBER","numType","NumberType","FLOAT","INTEGER","TEXT","getGeometryAttribute","geomAttribute","GEOMETRY"],"mappings":"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","file":"attributes.63303bbd6acf5d48be90.js","sourcesContent":["/**\n * @module app.attributes\n */\nlet exports = {};\n\n// webpack: import './common_dependencies.js';\nimport ngeoFormatXSDAttribute from 'ngeo/format/XSDAttribute.js';\n\n/** @suppress {extraRequire} */\nimport ngeoEditingAttributesComponent from 'ngeo/editing/attributesComponent.js';\n\nimport olFeature from 'ol/Feature.js';\nimport ngeoMapModule from 'ngeo/map/module.js';\n\n\n/** @type {!angular.Module} */\nexports.module = angular.module('app', [\n  ngeoMapModule.name,\n  ngeoEditingAttributesComponent.name,\n]);\n\n\n/**\n * @param {angular.$http} $http Angular http service.\n * @param {angular.$timeout} $timeout Angular timeout service.\n * @param {!angular.Scope} $scope Scope.\n * @ngInject\n * @constructor\n */\nexports.MainController = function($http, $timeout, $scope) {\n\n  /**\n   * @type {angular.$timeout}\n   * @private\n   */\n  this.timeout_ = $timeout;\n\n  /**\n   * @type {?Array.<ngeox.Attribute>}\n   * @export\n   */\n  this.attributes = null;\n\n  /**\n   * @type {boolean}\n   * @export\n   */\n  this.disabled = false;\n\n  /**\n   * @type {ol.Feature}\n   * @export\n   */\n  this.feature = new olFeature({\n    'name': 'A feature',\n    'kind': 'house'\n  });\n\n  $http.get('data/xsdattributes.xml').then(\n    this.handleXSDAttributeGet_.bind(this));\n\n  //\n  // Visual feedback for changes applied to feature:\n\n  /**\n   * @type {string}\n   * @export\n   */\n  this.log = '';\n\n  $scope.$watch(\n    () => this.feature.get('name'),\n    (newValue, oldValue) => {\n      if (newValue !== oldValue) {\n        this.appendLog(`name changed from '${oldValue}' to '${newValue}'`);\n      }\n    }\n  );\n\n  $scope.$watch(\n    () => this.feature.get('kind'),\n    (newValue, oldValue) => {\n      if (newValue !== oldValue) {\n        this.appendLog(`kind changed from '${oldValue}' to '${newValue}'`);\n      }\n    }\n  );\n};\n\n\n/**\n * @param {angular.$http.Response} resp Ajax response.\n * @return {Array.<ngeox.Attribute>} List of attributes.\n * @private\n */\nexports.MainController.prototype.handleXSDAttributeGet_ = function(resp) {\n  const format = new ngeoFormatXSDAttribute();\n  const attributes = format.read(resp.data);\n  this.attributes = attributes;\n  return attributes;\n};\n\n\n/**\n * @export\n */\nexports.MainController.prototype.updateName = function() {\n  this.timeout_(() => {\n    this.feature.set('name', 'An alternate name');\n  }, 0);\n};\n\n/**\n * @param {string} newMessage New message to add to log.\n */\nexports.MainController.prototype.appendLog = function(newMessage) {\n  this.log = `${newMessage}\\n${this.log}`;\n};\n\n\nexports.module.controller('MainController', exports.MainController);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./examples/attributes.js","/**\n * @module ngeo.format.XSDAttribute\n */\nimport googAsserts from 'goog/asserts.js';\nimport ngeoFormatAttribute from 'ngeo/format/Attribute.js';\nimport ngeoFormatAttributeType from 'ngeo/format/AttributeType.js';\nimport * as olBase from 'ol/index.js';\nimport olFormatXML from 'ol/format/XML.js';\n\n/**\n * @classdesc\n * Reads attributes that are defined in XSD format and return them as a list.\n *\n * @constructor\n * @struct\n * @extends {ol.format.XML}\n */\nconst exports = function() {\n  olFormatXML.call(this);\n};\n\nolBase.inherits(exports, olFormatXML);\n\n\n/**\n * @param {Document|Node|string} source Source.\n * @return {Array.<ngeox.Attribute>} The parsed result.\n * @override\n */\nexports.prototype.read = function(source) {\n  return (\n    /** @type {Array.<ngeox.Attribute>} */ olFormatXML.prototype.read.call(this, source)\n  );\n};\n\n\n/**\n * @param {Document} doc Document.\n * @return {Array.<ngeox.Attribute>} List of attributes.\n * @override\n */\nexports.prototype.readFromDocument = function(doc) {\n  googAsserts.assert(doc.nodeType == Node.DOCUMENT_NODE,\n    'doc.nodeType should be DOCUMENT');\n  for (let n = doc.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType == Node.ELEMENT_NODE) {\n      return this.readFromNode(n);\n    }\n  }\n  return null;\n};\n\n\n/**\n * @param {Node} node Node.\n * @return {Array.<ngeox.Attribute>} List of attributes.\n * @override\n */\nexports.prototype.readFromNode = function(node) {\n  googAsserts.assert(node.nodeType == Node.ELEMENT_NODE,\n    'node.nodeType should be ELEMENT');\n  googAsserts.assert(node.localName == 'schema',\n    'localName should be schema');\n\n  let elements = node.getElementsByTagName('element');\n  if (!elements.length) {\n    elements = node.getElementsByTagName('xsd:element');\n  }\n  const attributes = [];\n\n  let attribute;\n  for (let i = 0, ii = elements.length; i < ii; i++) {\n    attribute = this.readFromElementNode_(elements[i]);\n    if (attribute) {\n      attributes.push(attribute);\n    }\n  }\n\n  return attributes;\n};\n\n\n/**\n * @param {Node} node Node.\n * @return {?ngeox.Attribute} An attribute object.\n * @private\n */\nexports.prototype.readFromElementNode_ = function(node) {\n\n  const name = node.getAttribute('name');\n  googAsserts.assertString(name, 'name should be defined in element node.');\n\n  const alias = node.getAttribute('alias');\n  const nillable = node.getAttribute('nillable');\n  const required = !(nillable === true || nillable === 'true');\n\n  const attribute = {\n    name,\n    alias,\n    required\n  };\n\n  const type = node.getAttribute('type');\n  if (type) {\n    if (!ngeoFormatAttribute.setGeometryType(attribute, type)) {\n      this.setAttributeByXsdType_(attribute, type);\n    }\n  } else {\n\n    // Attribute has no type defined on 'element' node.  Try:\n\n    // (1) Enumerations\n    let enumerations = node.getElementsByTagName('enumeration');\n    if (!enumerations.length) {\n      enumerations = node.getElementsByTagName('xsd:enumeration');\n    }\n    if (enumerations.length) {\n      attribute.type = ngeoFormatAttributeType.SELECT;\n      const choices = [];\n      for (let i = 0, ii = enumerations.length; i < ii; i++) {\n        choices.push(enumerations[i].getAttribute('value'));\n      }\n      attribute.choices = choices;\n    } else {\n      // (2) Other types with restrictions\n      let restrictions = node.getElementsByTagName('restriction');\n      if (!restrictions.length) {\n        restrictions = node.getElementsByTagName('xsd:restriction');\n      }\n      if (restrictions.length && restrictions[0]) {\n        const restrictionNode = restrictions[0];\n        this.setAttributeByXsdType_(\n          attribute,\n          restrictionNode.getAttribute('base')\n        );\n        // MaxLength\n        let maxLengths = node.getElementsByTagName('maxLength');\n        if (!maxLengths.length) {\n          maxLengths = node.getElementsByTagName('xsd:maxLength');\n        }\n        if (maxLengths.length && maxLengths[0]) {\n          attribute.maxLength = Number(maxLengths[0].getAttribute('value'));\n        }\n      }\n    }\n  }\n\n  if (!attribute.type) {\n    return null;\n  }\n\n  googAsserts.assert(attribute.type);\n\n  return attribute;\n};\n\n\n/**\n * Set the `type` and `numType` properties of an attribute depending on the\n * given xsdType.\n *\n * @param {ngeox.AttributeBase} attribute Attribute.\n * @param {string} type The xsd type.\n * @private\n */\nexports.prototype.setAttributeByXsdType_ = function(\n  attribute, type\n) {\n  if (type === 'xsd:boolean') {\n    attribute.type = ngeoFormatAttributeType.BOOLEAN;\n  } else if (type === 'xsd:date') {\n    attribute.type = ngeoFormatAttributeType.DATE;\n  } else if (type === 'xsd:dateTime') {\n    attribute.type = ngeoFormatAttributeType.DATETIME;\n  } else if (type === 'xsd:time') {\n    attribute.type = ngeoFormatAttributeType.TIME;\n  } else if (type === 'xsd:decimal') {\n    attribute.type = ngeoFormatAttributeType.NUMBER;\n    attribute.numType = exports.NumberType.FLOAT;\n  } else if (type === 'xsd:integer') {\n    attribute.type = ngeoFormatAttributeType.NUMBER;\n    attribute.numType = exports.NumberType.INTEGER;\n  } else if (type === 'xsd:string') {\n    attribute.type = ngeoFormatAttributeType.TEXT;\n  }\n};\n\n\n/**\n * Returns the first geometry attribute among a given list of attributes.\n * @param {Array.<ngeox.Attribute>} attributes The list of attributes.\n * @return {?ngeox.Attribute} A geometry attribute object.\n */\nexports.getGeometryAttribute = function(attributes) {\n  let geomAttribute = null;\n  for (let i = 0, ii = attributes.length; i < ii; i++) {\n    if (attributes[i].type === ngeoFormatAttributeType.GEOMETRY) {\n      geomAttribute = attributes[i];\n      break;\n    }\n  }\n  return geomAttribute;\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nexports.NumberType = {\n  /**\n   * @type {string}\n   * @export\n   */\n  FLOAT: 'float',\n  /**\n   * @type {string}\n   * @export\n   */\n  INTEGER: 'integer'\n};\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/XSDAttribute.js"],"sourceRoot":""}