{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/format/XSDAttribute.js","webpack:///./examples/attributes.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fullfilled","j","depId","splice","__webpack_require__","s","installedModules","38","exports","module","l","m","c","d","name","getter","o","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","p","jsonpArray","window","oldJsonpFunction","bind","slice","olBase","_XML2","default","this","inherits","read","source","readFromDocument","doc","_asserts2","assert","nodeType","Node","DOCUMENT_NODE","firstChild","nextSibling","ELEMENT_NODE","readFromNode","node","localName","elements","getElementsByTagName","attributes","attribute","ii","readFromElementNode_","getAttribute","assertString","alias","nillable","required","type","_Attribute2","setGeometryType","setAttributeByXsdType_","enumerations","_AttributeType2","SELECT","choices","restrictions","restrictionNode","maxLengths","maxLength","Number","BOOLEAN","DATE","DATETIME","TIME","NUMBER","numType","NumberType","FLOAT","INTEGER","TEXT","getGeometryAttribute","geomAttribute","GEOMETRY","angular","_module2","_attributesComponent2","MainController","$http","$timeout","$scope","_this","timeout_","disabled","feature","_Feature2","kind","then","handleXSDAttributeGet_","log","$watch","newValue","oldValue","appendLog","resp","_XSDAttribute2","updateName","_this2","set","newMessage","controller"],"mappings":"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","file":"attributes.cbad2ea3707dbf6a77a2.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1]\n \t\tvar executeModules = data[2];\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fullfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fullfilled = false;\n \t\t\t}\n \t\t\tif(fullfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t38: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([420,0]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","/**\n * @module ngeo.format.XSDAttribute\n */\nimport googAsserts from 'goog/asserts.js';\nimport ngeoFormatAttribute from 'ngeo/format/Attribute.js';\nimport ngeoFormatAttributeType from 'ngeo/format/AttributeType.js';\nimport * as olBase from 'ol/index.js';\nimport olFormatXML from 'ol/format/XML.js';\n\n/**\n * @classdesc\n * Reads attributes that are defined in XSD format and return them as a list.\n *\n * @constructor\n * @struct\n * @extends {ol.format.XML}\n */\nconst exports = function() {\n  olFormatXML.call(this);\n};\n\nolBase.inherits(exports, olFormatXML);\n\n\n/**\n * @param {Document|Node|string} source Source.\n * @return {Array.<ngeox.Attribute>} The parsed result.\n * @override\n */\nexports.prototype.read = function(source) {\n  return (\n    /** @type {Array.<ngeox.Attribute>} */ olFormatXML.prototype.read.call(this, source)\n  );\n};\n\n\n/**\n * @param {Document} doc Document.\n * @return {Array.<ngeox.Attribute>} List of attributes.\n * @override\n */\nexports.prototype.readFromDocument = function(doc) {\n  googAsserts.assert(doc.nodeType == Node.DOCUMENT_NODE,\n    'doc.nodeType should be DOCUMENT');\n  for (let n = doc.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType == Node.ELEMENT_NODE) {\n      return this.readFromNode(n);\n    }\n  }\n  return null;\n};\n\n\n/**\n * @param {Node} node Node.\n * @return {Array.<ngeox.Attribute>} List of attributes.\n * @override\n */\nexports.prototype.readFromNode = function(node) {\n  googAsserts.assert(node.nodeType == Node.ELEMENT_NODE,\n    'node.nodeType should be ELEMENT');\n  googAsserts.assert(node.localName == 'schema',\n    'localName should be schema');\n\n  let elements = node.getElementsByTagName('element');\n  if (!elements.length) {\n    elements = node.getElementsByTagName('xsd:element');\n  }\n  const attributes = [];\n\n  let attribute;\n  for (let i = 0, ii = elements.length; i < ii; i++) {\n    attribute = this.readFromElementNode_(elements[i]);\n    if (attribute) {\n      attributes.push(attribute);\n    }\n  }\n\n  return attributes;\n};\n\n\n/**\n * @param {Node} node Node.\n * @return {?ngeox.Attribute} An attribute object.\n * @private\n */\nexports.prototype.readFromElementNode_ = function(node) {\n\n  const name = node.getAttribute('name');\n  googAsserts.assertString(name, 'name should be defined in element node.');\n\n  const alias = node.getAttribute('alias');\n  const nillable = node.getAttribute('nillable');\n  const required = !(nillable === true || nillable === 'true');\n\n  const attribute = {\n    name,\n    alias,\n    required\n  };\n\n  const type = node.getAttribute('type');\n  if (type) {\n    if (!ngeoFormatAttribute.setGeometryType(attribute, type)) {\n      this.setAttributeByXsdType_(attribute, type);\n    }\n  } else {\n\n    // Attribute has no type defined on 'element' node.  Try:\n\n    // (1) Enumerations\n    let enumerations = node.getElementsByTagName('enumeration');\n    if (!enumerations.length) {\n      enumerations = node.getElementsByTagName('xsd:enumeration');\n    }\n    if (enumerations.length) {\n      attribute.type = ngeoFormatAttributeType.SELECT;\n      const choices = [];\n      for (let i = 0, ii = enumerations.length; i < ii; i++) {\n        choices.push(enumerations[i].getAttribute('value'));\n      }\n      attribute.choices = choices;\n    } else {\n      // (2) Other types with restrictions\n      let restrictions = node.getElementsByTagName('restriction');\n      if (!restrictions.length) {\n        restrictions = node.getElementsByTagName('xsd:restriction');\n      }\n      if (restrictions.length && restrictions[0]) {\n        const restrictionNode = restrictions[0];\n        this.setAttributeByXsdType_(\n          attribute,\n          restrictionNode.getAttribute('base')\n        );\n        // MaxLength\n        let maxLengths = node.getElementsByTagName('maxLength');\n        if (!maxLengths.length) {\n          maxLengths = node.getElementsByTagName('xsd:maxLength');\n        }\n        if (maxLengths.length && maxLengths[0]) {\n          attribute.maxLength = Number(maxLengths[0].getAttribute('value'));\n        }\n      }\n    }\n  }\n\n  if (!attribute.type) {\n    return null;\n  }\n\n  googAsserts.assert(attribute.type);\n\n  return attribute;\n};\n\n\n/**\n * Set the `type` and `numType` properties of an attribute depending on the\n * given xsdType.\n *\n * @param {ngeox.AttributeBase} attribute Attribute.\n * @param {string} type The xsd type.\n * @private\n */\nexports.prototype.setAttributeByXsdType_ = function(\n  attribute, type\n) {\n  if (type === 'xsd:boolean') {\n    attribute.type = ngeoFormatAttributeType.BOOLEAN;\n  } else if (type === 'xsd:date') {\n    attribute.type = ngeoFormatAttributeType.DATE;\n  } else if (type === 'xsd:dateTime') {\n    attribute.type = ngeoFormatAttributeType.DATETIME;\n  } else if (type === 'xsd:time') {\n    attribute.type = ngeoFormatAttributeType.TIME;\n  } else if (type === 'xsd:decimal') {\n    attribute.type = ngeoFormatAttributeType.NUMBER;\n    attribute.numType = exports.NumberType.FLOAT;\n  } else if (type === 'xsd:integer') {\n    attribute.type = ngeoFormatAttributeType.NUMBER;\n    attribute.numType = exports.NumberType.INTEGER;\n  } else if (type === 'xsd:string') {\n    attribute.type = ngeoFormatAttributeType.TEXT;\n  }\n};\n\n\n/**\n * Returns the first geometry attribute among a given list of attributes.\n * @param {Array.<ngeox.Attribute>} attributes The list of attributes.\n * @return {?ngeox.Attribute} A geometry attribute object.\n */\nexports.getGeometryAttribute = function(attributes) {\n  let geomAttribute = null;\n  for (let i = 0, ii = attributes.length; i < ii; i++) {\n    if (attributes[i].type === ngeoFormatAttributeType.GEOMETRY) {\n      geomAttribute = attributes[i];\n      break;\n    }\n  }\n  return geomAttribute;\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nexports.NumberType = {\n  /**\n   * @type {string}\n   * @export\n   */\n  FLOAT: 'float',\n  /**\n   * @type {string}\n   * @export\n   */\n  INTEGER: 'integer'\n};\n\n\nexport default exports;\n","/**\n * @module app.attributes\n */\nconst exports = {};\n\nimport './common_dependencies.js';\nimport ngeoFormatXSDAttribute from 'ngeo/format/XSDAttribute.js';\n\n/** @suppress {extraRequire} */\nimport ngeoEditingAttributesComponent from 'ngeo/editing/attributesComponent.js';\n\nimport olFeature from 'ol/Feature.js';\nimport ngeoMapModule from 'ngeo/map/module.js';\n\n\n/** @type {!angular.Module} */\nexports.module = angular.module('app', [\n  ngeoMapModule.name,\n  ngeoEditingAttributesComponent.name,\n]);\n\n\n/**\n * @param {angular.$http} $http Angular http service.\n * @param {angular.$timeout} $timeout Angular timeout service.\n * @param {!angular.Scope} $scope Scope.\n * @ngInject\n * @constructor\n */\nexports.MainController = function($http, $timeout, $scope) {\n\n  /**\n   * @type {angular.$timeout}\n   * @private\n   */\n  this.timeout_ = $timeout;\n\n  /**\n   * @type {?Array.<ngeox.Attribute>}\n   * @export\n   */\n  this.attributes = null;\n\n  /**\n   * @type {boolean}\n   * @export\n   */\n  this.disabled = false;\n\n  /**\n   * @type {ol.Feature}\n   * @export\n   */\n  this.feature = new olFeature({\n    'name': 'A feature',\n    'kind': 'house'\n  });\n\n  $http.get('data/xsdattributes.xml').then(\n    this.handleXSDAttributeGet_.bind(this));\n\n  //\n  // Visual feedback for changes applied to feature:\n\n  /**\n   * @type {string}\n   * @export\n   */\n  this.log = '';\n\n  $scope.$watch(\n    () => this.feature.get('name'),\n    (newValue, oldValue) => {\n      if (newValue !== oldValue) {\n        this.appendLog(`name changed from '${oldValue}' to '${newValue}'`);\n      }\n    }\n  );\n\n  $scope.$watch(\n    () => this.feature.get('kind'),\n    (newValue, oldValue) => {\n      if (newValue !== oldValue) {\n        this.appendLog(`kind changed from '${oldValue}' to '${newValue}'`);\n      }\n    }\n  );\n};\n\n\n/**\n * @param {angular.$http.Response} resp Ajax response.\n * @return {Array.<ngeox.Attribute>} List of attributes.\n * @private\n */\nexports.MainController.prototype.handleXSDAttributeGet_ = function(resp) {\n  const format = new ngeoFormatXSDAttribute();\n  const attributes = format.read(resp.data);\n  this.attributes = attributes;\n  return attributes;\n};\n\n\n/**\n * @export\n */\nexports.MainController.prototype.updateName = function() {\n  this.timeout_(() => {\n    this.feature.set('name', 'An alternate name');\n  }, 0);\n};\n\n/**\n * @param {string} newMessage New message to add to log.\n */\nexports.MainController.prototype.appendLog = function(newMessage) {\n  this.log = `${newMessage}\\n${this.log}`;\n};\n\n\nexports.module.controller('MainController', exports.MainController);\n\n\nexport default exports;\n"],"sourceRoot":""}